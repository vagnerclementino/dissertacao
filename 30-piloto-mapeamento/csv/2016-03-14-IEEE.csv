"Key","Item Type","Publication Year","Author","Title","Publication Title","ISBN","ISSN","DOI","Url","Abstract Note","Date","Date Added","Date Modified","Access Date","Pages","Num Pages","Issue","Volume","Number Of Volumes","Journal Abbreviation","Short Title","Series","Series Number","Series Text","Series Title","Publisher","Place","Language","Rights","Type","Archive","Archive Location","Library Catalog","Call Number","Extra","Notes","File Attachments","Link Attachments","Manual Tags","Automatic Tags","Editor","Series Editor","Translator","Contributor","Attorney Agent","Book Author","Cast Member","Commenter","Composer","Cosponsor","Counsel","Interviewer","Producer","Recipient","Reviewed Author","Scriptwriter","Words By","Guest","Number","Edition","Running Time","Scale","Medium","Artwork Size","Filing Date","Application Number","Assignee","Issuing Authority","Country","Meeting Name","Conference Name","Court","References","Reporter","Legal Status","Priority Numbers","Programming Language","Version","System","Code","Code Number","Section","Session","Committee","History","Legislative Body"
"JAEMJA8I","conferencePaper","2012","Schwerz, A. L.; Liberato, R.; Wiese, I. S.; Steinmacher, I.; Gerosa, M. A.; Ferreira, J. E.","Prediction of Developer Participation in Issues of Open Source Projects","Collaborative Systems (SBSC), 2012 Brazilian Symposium on","","","10.1109/SBSC.2012.27","","Developers of distributed open source projects use management and issues tracking tool to communicate. These tools provide a large volume of unstructured information that makes the triage of issues difficult, increasing developers' overhead. This problem is common to online communities based on volunteer participation. This paper shows the importance of the content of comments in an open source project to build a classifier to predict the participation for a developer in an issue. To design this prediction model, we used two machine learning algorithms called Naive Bayes and J48. We used the data of three Apache Hadoop subprojects to evaluate the use of the algorithms. By applying our approach to the most active developers of these subprojects we have achieved an accuracy ranging from 79% to 96%. The results indicate that the content of comments in issues of open source projects is a relevant factor to build a classifier of issues for developers.","2012-10","2016-03-14 21:38:50","2016-03-14 21:38:50","","109-114","","","","","","","","","","","","","","","","","","","","","","","","Apache Hadoop subprojects; Argon; Bayesian methods; Content analysis; developer participation; distributed open source projects; Electronic mail; issue tracking classifier; learning (artificial intelligence); machine learning; machine learning algorithm; Machine learning algorithms; naive Bayes; prediction model; Predictive models; public domain software; Random access memory; Software; tracking tool; unstructured information; volunteer participation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"UBSNCH7K","conferencePaper","2011","Lamkanfi, A.; Demeyer, S.; Soetens, Q. D.; Verdonck, T.","Comparing Mining Algorithms for Predicting the Severity of a Reported Bug","Software Maintenance and Reengineering (CSMR), 2011 15th European Conference on","","","10.1109/CSMR.2011.31","","A critical item of a bug report is the so-called ""severity"", i.e. the impact the bug has on the successful execution of the software system. Consequently, tool support for the person reporting the bug in the form of a recommender or verification system is desirable. In previous work we made a first step towards such a tool: we demonstrated that text mining can predict the severity of a given bug report with a reasonable accuracy given a training set of sufficient size. In this paper we report on a follow-up study where we compare four well-known text mining algorithms (namely, Naive Bayes, Naive Bayes Multinomial, K-Nearest Neighbor and Support Vector Machines) with respect to accuracy and training set size. We discovered that for the cases under investigation (two open source systems: Eclipse and GNOME) Naive Bayes Multinomial performs superior compared to the other proposed algorithms.","2011-03","2016-03-14 21:38:51","2016-03-14 21:38:51","","249-258","","","","","","","","","","","","","","","","","","","","","","","","Accuracy; bug report; Bug Reports; Bug Severity; Bugzilla; Computer bugs; data mining; Eclipse; GNOME; K-nearest neighbor; mining algorithm; naive Bayes; naive Bayes multinomial; Prediction algorithms; program debugging; program verification; Software; software system; support vector machines; text analysis; text mining; Training; verification system","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"B7VUEI3U","conferencePaper","2014","Meurice, L.; Cleve, A.","DAHLIA: A visual analyzer of database schema evolution","Software Maintenance, Reengineering and Reverse Engineering (CSMR-WCRE), 2014 Software Evolution Week - IEEE Conference on","","","10.1109/CSMR-WCRE.2014.6747219","","In a continuously changing environment, software evolution becomes an unavoidable activity. The mining software repositories (MSR) field studies the valuable data available in software repositories such as source code version-control systems, issue/bug-tracking systems, or communication archives. In recent years, many researchers have used MSR techniques as a way to support software understanding and evolution. While many software systems are data-intensive, i.e., their central artefact is a database, little attention has been devoted to the analysis of this important system component in the context of software evolution. The goal of our work is to reduce this gap by considering the database evolution history as an additional information source to aid software evolution. We present DAHLIA (Database ScHema EvoLutIon Analysis), a visual analyzer of database schema evolution. Our tool mines the database schema evolution history from the software repository and allows its interactive, visual analysis. We describe DAHLIA and present our novel approach supporting data-intensive software evolution.","2014-02","2016-03-14 21:38:51","2016-03-14 21:38:51","","464-468","","","","","","","","","","","","","","","","","","","","","","","","bug tracking systems; communication archives; DAHLIA; database management systems; database schema evolution; data-intensive software evolution; data mining; data visualisation; History; Indexes; issue tracking systems; mining software repositories field; MSR techniques; program debugging; software maintenance; Software systems; software understanding; source code (software); source code version-control systems; visual analyzer; Visual databases; Visualization","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"XEFVZGQX","conferencePaper","2014","Hamlaoui, M. El; Ebersold, S.; Coulette, B.; Nassar, M.; Anwar, A.","Heterogeneous models matching for consistency management","Research Challenges in Information Science (RCIS), 2014 IEEE Eighth International Conference on","","","10.1109/RCIS.2014.6861074","","This work is situated in the context of the application of Model Driven Engineering to complex systems view-based modelling. In fact, view-based models - called also partial models - are manipulated by different actors (designers), and are thus generally heterogeneous, that is, described with different DSLs (Domain Specific Languages). Instead of building a single global model, which is not realistic, we propose to organize the different partial models as a network of related models, which provides a global view of the system through a correspondence model. As models are modelled separately by different designers, they also evolve separately that induces a problem of consistency. To solve it, we propose a semi-automatic process based on the correspondence model allowing detecting changes, calculating their impacts, and proposing modifications to maintain the consistency among them. The approach is supported by a tool chain and illustrated by the example of a Bug Tracking System.","2014-05","2016-03-14 21:38:51","2016-03-14 21:38:51","","1-12","","","","","","","","","","","","","","","","","","","","","","","","Abstracts; Adaptation models; Analytical models; Business; change processing; consistency; consistency management; correspondence model; Domain Specific Languages; DSL; heterogeneous model matching; Heterogeneous models; Information systems; model driven engineering; software engineering; Unified modeling language","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"P48TXI9B","journalArticle","2009","Gall, H. C.; Fluri, B.; Pinzger, M.","Change Analysis with Evolizer and ChangeDistiller","IEEE Software","","0740-7459","10.1109/MS.2009.6","","Evolizer a platform for mining software archives, and ChangeDistiller, a change extraction and analysis tool, enable the retrospective analysis of a software system's evolution.","2009-01","2016-03-14 21:38:52","2016-03-14 21:38:52","","26-33","","1","26","","","","","","","","","","","","","","","","","","","","","change analysis; ChangeDistiller; configuration management; Costs; data mining; enhancement; Evolizer; Feedback; fine-grained change type analysis; fine-grained change type extraction; History; Information analysis; integrated development environment; issue-tracking systems; Java; maintenance; management of change; Project management; recommender systems; software archives; software development management; software evolution analysis; software prototyping; Software systems; Software tools; source code version-control systems; Taxonomy; technology requirements; version control","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"FKKDJF6D","conferencePaper","2010","Clarke, J.; Vines, J.; Kirk, K.; Mark, E.; Angelini, R.; Spear, C.; Waisbrot, N.; Martin, J.; Leiter, K.; Hoffman, B.","A Common Computational Science Environment for High Performance Computing Centers","High Performance Computing Modernization Program Users Group Conference (HPCMP-UGC), 2010 DoD","","","10.1109/HPCMP-UGC.2010.68","","The Computational Sciences Environment (CSE) was developed to provide a standard development platform for data analysis, visualization, and software testing and evaluation. The Classified Data Analysis and Assessment Center (CDAAC), in conjunction with the Computational Sciences and Engineering Branch (CSEB) of the Army Research Laboratory, assembled a set of open source data analysis tools and applications, software management and testing tools, and libraries necessary to run the tools; and made them available as a package called CSE. CSE also provides experimental software builds for users who might need newer features than what is currently available in the release package. The CSE team provides support for developers, the end-user, and distributed development teams. Tests are regularly run on the software, both current and release, and the results are submitted to quality dashboards for review using CTest. CTest is part of an open-source software building tool called CMake. Developers can use CSE as a template and can customize it to meet their specific project goals. CSE provides developers with a common tool set to assist in developing portable high performance computing (HPC) Applications. Development of CSE has been managed through an open-source project management application that provides Software Configuration Management (SCM) integration of the CSE repository, informational wikis, bug tracking, and feature requests. To support distributed development teams, CSE provides project management tools, software repositories, SCM, and online software quality dashboards.","2010-06","2016-03-14 21:38:52","2016-03-14 21:38:52","","442-449","","","","","","","","","","","","","","","","","","","","","","","","Buildings; classified data analysis and assessment center; computational science environment; computer centres; CSE; CTest; data analysis; data visualisation; data visualization; high performance computing centre; informational wikis; libraries; open source software; program testing; Project management; project management tools; public domain software; quality dashboards; SCM; Software; software configuration management; software libraries; software management; software package; software packages; software quality; software repositories; software testing; Software tools; Testing; US Department of Defense","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"DNUHCHW7","conferencePaper","2014","Huo, D.; Ding, T.; McMillan, C.; Gethers, M.","An Empirical Study of the Effects of Expert Knowledge on Bug Reports","Software Maintenance and Evolution (ICSME), 2014 IEEE International Conference on","","","10.1109/ICSME.2014.22","","Bug reports are crucial software artifacts for both software maintenance researchers and practitioners. A typical use of bug reports by researchers is to evaluate automated software maintenance tools: a large repository of reports is used as input for a tool, and metrics are calculated from the tool's output. But this process is quite different from practitioners, who distinguish between reports written by experts such as programmers, and reports written by non-experts such as users. Practitioners recognize that the content of a bug report depends on its author's expert knowledge. In this paper, we present an empirical study of the textual difference between bug reports written by experts and non-experts. We find that a significance difference exists, and that this difference has a significant impact on the results from a state-of-the-art feature location tool. Our recommendation is that researchers evaluate maintenance tools using different sets of bug reports for experts and non-experts.","2014-09","2016-03-14 21:38:52","2016-03-14 21:38:52","","1-10","","","","","","","","","","","","","","","","","","","","","","","","automated software maintenance tool evaluation; bug report content; Bug Reports; Computer bugs; empirical analysis; empirical study; expert knowledge; feature location tool; Information retrieval; large-report repository; Maintenance engineering; Measurement; program debugging; Semantics; software artifacts; software maintenance; software maintenance practitioners; software maintenance researchers; software metrics; textual difference","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"CQ2K4ZKB","conferencePaper","2014","Le, T. D. B.; Thung, F.; Lo, D.","Predicting Effectiveness of IR-Based Bug Localization Techniques","Software Reliability Engineering (ISSRE), 2014 IEEE 25th International Symposium on","","","10.1109/ISSRE.2014.39","","Recently, many information retrieval (IR) based bug localization approaches have been proposed in the literature. These approaches use information retrieval techniques to process a textual bug report and a collection of source code files to find buggy files. They output a ranked list of files sorted by their likelihood to contain the bug. Recent approaches can achieve reasonable accuracy, however, even a state-of-the-art bug localization tool outputs many ranked lists where buggy files appear very low in the lists. This potentially causes developers to distrust bug localization tools. Parnin and Orso recently conduct a user study and highlight that developers do not find an automated debugging tool useful if they do not find the root cause of a bug early in a ranked list. To address this problem, we build an oracle that can automatically predict whether a ranked list produced by an IR-based bug localization tool is likely to be effective or not. We consider a ranked list to be effective if a buggy file appears in the top-N position of the list. If a ranked list is unlikely to be effective, developers do not need to waste time in checking the recommended files one by one. In such cases, it is better for developers to use traditional debugging methods or request for further information to localize bugs. To build this oracle, our approach extracts features that can be divided into four categories: score features, textual features, topic model features, and metadata features. We build a separate prediction model for each category, and combine them to create a composite prediction model which is used as the oracle. We name our proposed approach APRILE, which stands for Automated Prediction of IR-based Bug Localization's Effectiveness. We have evaluated APRILE to predict the effectiveness of three state-of-the-art IR based bug localization tools on more than three thousands bug reports from AspectJ, Eclipse, and SWT. APRILE can achieve an average precision, recall, and - -measure of at least 70.36%, 66.94%, and 68.03%, respectively. Furthermore, APRILE outperforms a baseline approach by 84.48%, 17.74%, and 31.56% for the AspectJ, Eclipse, and SWT bug reports, respectively.","2014-11","2016-03-14 21:38:53","2016-03-14 21:38:53","","335-345","","","","","","","","","","","","","","","","","","","","","","","","APRILE; AspectJ; automated debugging tool; automated prediction of IR-based bug localization effectiveness; buggy files; Bug Localization; bug localization tool; Bug Reports; composite prediction model; Computational modeling; Computer bugs; Debugging; Eclipse; Effectiveness Prediction; feature extraction; Information retrieval; information retrieval based bug localization approach; information retrieval techniques; IR-based bug localization techniques; meta data; metadata features; Predictive models; program debugging; recommended files; score features; source code files; source code (software); support vector machines; SWT; Text Classification; textual bug report; textual features; topic model features; traditional debugging method; Training","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"5956KN3C","conferencePaper","2007","Francisco, M. P.; Perez, P. B.; Robles, G.","Correlation between bug notifications, messages and participants in Debian's bug tracking system","Empirical Software Engineering and Measurement, 2007. ESEM 2007. First International Symposium on","","","10.1109/ESEM.2007.65","","Bugs are an essential part of software projects because they lead its evolution. Without bug notifications developers cannot know if their software is accomplishing its tasks properly. However, few analytical studies have been made about this aspect of projects. We have developed a tool to extract and to store information from Debian's BTS (Bug Tracking System) in a relational database. In this paper we show that there is a strong dependence between three variables which can be used to analyze the activity of a project through its bugs: bug notifications, communications between users and developers and people involved.","2007-09","2016-03-14 21:38:53","2016-03-14 21:38:53","","455-457","","","","","","","","","","","","","","","","","","","","","","","","bug notifications; Computer bugs; Control systems; data mining; Debian bug tracking system; Information retrieval; Internet; Packaging; Particle measurements; program debugging; relational database; relational databases; software engineering; Software measurement; software projects","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"DAVG5TDH","conferencePaper","2009","Ye, En; Neiman, L. A.; Dinh, H. Q.; Liu, C.","SecondWATCH: A workspace awareness tool based on a 3-D virtual world","Software Engineering - Companion Volume, 2009. ICSE-Companion 2009. 31st International Conference on","","","10.1109/ICSE-COMPANION.2009.5071004","","Awareness of fellow developers' activities has been widely recognized as essential in facilitating collaboration in a software developing team. However, as reported in several field studies on software development, awareness information on software artifact and coworker is difficult to acquire. To help software developers maintain group awareness and enhance their collaboration, we developed a prototype workspace awareness tool called SecondWATCH based on Second Life, a 3D online virtual world. SecondWATCH informs developers of real-time and history artifact and coworker information by monitoring team members' activities on their local workspaces, version control repository, and bug tracking system. It then extracts, analyzes, and visualizes the information in SL as a common view shared by the whole team using a 3-D city metaphor. We have successfully used SecondWATCH to visualize history information of three open-source Java projects, Free-Mind, JEdit, and GUJ, and also using it as our workspace awareness tool when we are developing it.","2009-05","2016-03-14 21:38:54","2016-03-14 21:38:54","","291-294","","","","","","","","","","","","","","","","","","","","","","","","3-D online virtual world; avatar; avatars; bug tracking system; Collaborative software; Collaborative tools; Collaborative work; configuration management; coworker information; Fellows; group awareness; groupware; History; Online Communities/Technical Collaboration; program debugging; Programming; SecondWATCH; software artifact; software development management; software development team; software maintenance; Software tools; version control repository; Visualization; workspace awareness tool","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"GVJMIXEQ","conferencePaper","2015","Maalej, W.; Nabil, H.","Bug report, feature request, or simply praise? On automatically classifying app reviews","Requirements Engineering Conference (RE), 2015 IEEE 23rd International","","","10.1109/RE.2015.7320414","","App stores like Google Play and Apple AppStore have over 3 Million apps covering nearly every kind of software and service. Billions of users regularly download, use, and review these apps. Recent studies have shown that reviews written by the users represent a rich source of information for the app vendors and the developers, as they include information about bugs, ideas for new features, or documentation of released features. This paper introduces several probabilistic techniques to classify app reviews into four types: bug reports, feature requests, user experiences, and ratings. For this we use review metadata such as the star rating and the tense, as well as, text classification, natural language processing, and sentiment analysis techniques. We conducted a series of experiments to compare the accuracy of the techniques and compared them with simple string matching. We found that metadata alone results in a poor classification accuracy. When combined with natural language processing, the classification precision got between 70-95% while the recall between 80-90%. Multiple binary classifiers outperformed single multiclass classifiers. Our results impact the design of review analytics tools which help app vendors, developers, and users to deal with the large amount of reviews, filter critical reviews, and assign them to the appropriate stakeholders.","2015-08","2016-03-14 21:38:54","2016-03-14 21:38:54","","116-125","","","","","","","","","","","","","","","","","","","","","","","","Accuracy; Apple AppStore; app reviews classification; App stores; bug report; Computer crashes; data mining; feature requests; Google; Google Play; Machine learning algorithms; Metadata; multiclass classifiers; multiple binary classifiers; natural language processing; pattern classification; probability; review analytics tool design; review metadata; sentiment analysis techniques; several probabilistic techniques; software reviews; star rating; string matching; text analysis; Text Classification; Training; user experiences","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"53IUN4H4","conferencePaper","2011","Ghezzi, G.; Gall, H. C.","SOFAS: A Lightweight Architecture for Software Analysis as a Service","Software Architecture (WICSA), 2011 9th Working IEEE/IFIP Conference on","","","10.1109/WICSA.2011.21","","Access to data stored in software repositories by systems such as version control, bug and issue tracking, or mailing lists is essential for assessing the quality of a software system. A myriad of analyses exploiting that data have been proposed throughout the years: source code analysis, code duplication analysis, co-change analysis, bug prediction, or detection of bug fixing patterns. However, easy and straight forward synergies between these analyses rarely exist. To tackle this problem we have developed SOFAS, a distributed and collaborative software analysis platform to enable a seamless interoperation of such analyses. In particular, software analyses are offered as Restful web services that can be accessed and composed over the Internet. SOFAS services are accessible through a software analysis catalog where any project stakeholder can, depending on the needs or interests, pick specific analyses, combine them, let them run remotely and then fetch the final results. That way, software developers, testers, architects, or quality assurance experts are given access to quality analysis services. They are shielded from many peculiarities of tool installations and configurations, but SOFAS offers them sophisticated and easy-to-use analyses. This paper describes in detail our SOFAS architecture, its considerations and implementation aspects, and the current set of implemented and offered Restful analysis services.","2011-06","2016-03-14 21:38:55","2016-03-14 21:38:55","","93-102","","","","","","","","","","","","","","","","","","","","","","","","bug fixing pattern; bug prediction; cochange analysis; code duplication analysis; collaborative software analysis platform; Computer architecture; Couplings; data access; groupware; History; Information retrieval; Internet; issue tracking; lightweight architecture; mailing list; Measurement; Ontologies; program testing; quality analysis service; quality assurance expert; RESTful Web service; service-oriented architecture; SOFAS; Software; software analysis as a service; software developer; software quality; software repository; source code analysis; version control; Web services","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"2ZWCAEC2","conferencePaper","2014","Xia, X.; Lo, D.; Qiu, W.; Wang, X.; Zhou, B.","Automated Configuration Bug Report Prediction Using Text Mining","Computer Software and Applications Conference (COMPSAC), 2014 IEEE 38th Annual","","","10.1109/COMPSAC.2014.17","","Configuration bugs are one of the dominant causes of software failures. Previous studies show that a configuration bug could cause huge financial losses in a software system. The importance of configuration bugs has attracted various research studies, e.g., To detect, diagnose, and fix configuration bugs. Given a bug report, an approach that can identify whether the bug is a configuration bug could help developers reduce debugging effort. We refer to this problem as configuration bug reports prediction. To address this problem, we develop a new automated framework that applies text mining technologies on the natural-language description of bug reports to train a statistical model on historical bug reports with known labels (i.e., Configuration or non-configuration), and the statistical model is then used to predict a label for a new bug report. Developers could apply our model to automatically predict labels of bug reports to improve their productivity. Our tool first applies feature selection techniques (e.g., Information gain and Chi-square) to pre-process the textual information in bug reports, and then applies various text mining techniques (e.g., Naive Bayes, SVM, naive Bayes multinomial) to build statistical models. We evaluate our solution on 5 bug report datasets including accumulo, activemq, camel, flume, and wicket. We show that naive Bayes multinomial with information gain achieves the best performance. On average across the 5 projects, its accuracy, configuration F-measure and non-configuration F-measure are 0.811, 0.450, and 0.880, respectively. We also compare our solution with the method proposed by Arshad et al. The results show that our proposed approach that uses naive Bayes multinomial with information gain on average improves accuracy, configuration F-measure and non-configuration F-measure scores of Arshad et al.'s method by 8.34%, 103.7%, and 4.24%, respectively.","2014-07","2016-03-14 21:38:55","2016-03-14 21:38:55","","107-116","","","","","","","","","","","","","","","","","","","","","","","","accumulo; activemq; bug detection; bug diagnosis; Buildings; camel; Computer bugs; Configuration Bug; configuration bug report prediction; configuration F-measure; data mining; debugging effort; feature extraction; Feature Selection; feature selection techniques; flume; information gain; naive Bayes multinomial; natural-language description; Predictive models; program debugging; software failure; statistical analysis; statistical model; support vector machines; text analysis; text mining; Training; wicket","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"WV3BQRQF","conferencePaper","2011","D'Ambros, M.; Robbes, R.","Effective mining of software repositories","Software Maintenance (ICSM), 2011 27th IEEE International Conference on","","","10.1109/ICSM.2011.6080839","","With the advent of open-source, the Internet, and the consequent widespread adoption of distributed development tools, such as software configuration management and issue tracking systems, a vast amount of valuable information concerning software development and evolution has become available. Mining Software Repositories (MSR)-a very active and interest-growing research field-deals with retrieving and analyzing this data. Empirical analyses of software repositories allow researchers to validate assumptions previously based only on intuitions, as well as finding novel theories. In turn, these theories about the software development phenomenon have been translated into concrete approaches and tools that support software developers and managers in their daily tasks. In this tutorial, we provide an overview of the state of the art of MSR. In particular, we describe what software repositories are, what in turn Mining Software Repositories is, what techniques are available to researchers and practitioners, and finally, what the limitations of MSR are nowadays, and how to fix them.","2011-09","2016-03-14 21:38:55","2016-03-14 21:38:55","","598-598","","","","","","","","","","","","","","","","","","","","","","","","configuration management; data mining; distributed development tool; Internet; issue tracking system; mining software repositories; MSR; software configuration management; software development; software evolution; software maintenance","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"A8ZAIBWB","conferencePaper","2015","Jiang, Shihai; Shen, Liwei; Peng, Xin; Lv, Zhaojin; Zhao, Wenyun","Understanding developers' natural language queries with interactive clarification","Software Analysis, Evolution and Reengineering (SANER), 2015 IEEE 22nd International Conference on","","","10.1109/SANER.2015.7081811","","When performing software maintenance tasks, developers often need to understand a series of background knowledge based on information distributed in different software repositories such as source codes, version control systems and bug tracking systems. An effective way to support developers to understand such knowledge is to provide an integrated knowledge base and allow them to ask questions using natural language. Existing approaches cannot well support natural language questions that involve a series of conceptual relationships and are phrased in a flexible way. In this paper, we propose an interactive approach for understanding developers' natural language queries. The approach can understand a developer's natural language questions phrased in different ways by generating a set of ranked and human-readable candidate questions and getting feedback from the developer. Based on the candidate question confirmed by the developer, the approach can then synthesize an answer by constructing and executing a structural query to the knowledge base. We have implemented a tool following the proposed approach and conducted a user study using the tool. The results show that our approach can help developers get the desired answers more easily and accurately.","2015-03","2016-03-14 21:38:56","2016-03-14 21:38:56","","13-22","","","","","","","","","","","","","","","","","","","","","","","","bug tracking systems; Computer bugs; developers; human-readable candidate questions; interactive clarification; knowledge base; knowledge based systems; natural language processing; natural language queries; natural language questions; Natural languages; Navigation; Ontologies; OWL; program debugging; query processing; Software; software maintenance; software maintenance tasks; software repositories; source codes; source code (software); structural query; version control systems","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"C3D6D8UB","conferencePaper","2011","Kaushik, N.; Tahvildari, L.; Moore, M.","Reconstructing Traceability between Bugs and Test Cases: An Experimental Study","Reverse Engineering (WCRE), 2011 18th Working Conference on","","","10.1109/WCRE.2011.58","","In manual testing, testers typically follow the steps listed in the bug report to verify whether a bug has been fixed or not. Depending on time and availability of resources, a tester may execute some additional test cases to ensure test coverage. In the case of manual testing, the process of finding the most relevant manual test cases to run is largely manual and involves tester expertise. From a usability standpoint, the task of finding the most relevant test cases is tedious as the tester typically has to switch between the defect management tool and the test case management tool in order to search for test cases relevant to the bug at hand. In this paper, we use IR techniques to recover trace ability between bugs and test cases with the aim of recommending test cases for bugs. We report on our experience of recovering trace ability between bugs and test cases using techniques such as Latent Semantic Indexing (LSI) and Latent Dirichlet Allocation (LDA) through a small industrial case study.","2011-10","2016-03-14 21:38:56","2016-03-14 21:38:56","","411-414","","","","","","","","","","","","","","","","","","","","","","","","bug; bug report; Computer bugs; Couplings; defect management tool; Indexing; IR techniques; Large scale integration; latent dirichlet allocation; latent semantic indexing; LSI; Manuals; manual testing; program diagnostics; program testing; Semantics; test case; test case management tool; test cases; Testing; traceability; traceability reconstruction; usability standpoint","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"E75TV42J","conferencePaper","2013","Davies, S.; Roper, M.","Bug localisation through diverse sources of information","Software Reliability Engineering Workshops (ISSREW), 2013 IEEE International Symposium on","","","10.1109/ISSREW.2013.6688891","","Many approaches have been proposed to address the problem of bug localisation - taking a bug report and recommending to developers the possible locations of the bug in the project. However, these can often require significant up-front work from developers, and are not widely adopted. Furthermore, those techniques which do not require this up-front investment are often far from accurate, and do not take advantage of all of the information that they could. We propose a technique for combining information from multiple, novel sources of information about a project and a bug, and use this to recommend bug locations to developers. We also identify how this technique could be used to create a low-effort tool for bug localisation, with the aim of increasing developer adoption. We evaluate the technique on 1143 bugs in three open-source projects, and find that it can be used to increase the number of bugs where the first relevant method recommended to developers is the top result from 98 to 132 and in the top-10 from 271 to 322.","2013-11","2016-03-14 21:38:57","2016-03-14 21:38:57","","126-131","","","","","","","","","","","","","","","","","","","","","","","","bug localisation; bug report; Computer bugs; Computers; Data models; History; information sources; Linear regression; mining software repositories; open-source projects; open source software; program debugging; Project management; software management; up-front technique","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"FHQBG7MW","conferencePaper","2011","Murray, M. C.","Work in progress #x2014; Creating a professional software development environment to support capstone programming projects","Frontiers in Education Conference (FIE), 2011","","","10.1109/FIE.2011.6143100","","Experiential education provides valuable learning opportunities for students in the computing disciplines. Assigning students to work on real-world projects is often seen as a way for students to practice what they have learned in the classroom. While a desirable goal, logistics often make it difficult to provide these types of experiences. However, it is vitally important for students to be exposed to and experiment with tools used in commercial software development environments. This paper provides a descriptive overview of the development and implementation of a professional software development environment used to support computer science capstone programming projects. To date, the environment has been used to support work on a National Science Foundation funded database courseware project that includes over 100 interactive software modules. The environment was built using a collection of open-source applications that provide version control, task assignment and tracking, collaborative team tools, bug tracking, and project documentation management. This project has created a venue for providing consistent high quality real-world types of experiences for students completing their capstone requirement.","2011-10","2016-03-14 21:38:57","2016-03-14 21:38:57","","S4F-1-S4F-3","","","","","","","","","","","","","","","","","","","","","","","","bug tracking; Capstone projects; collaborative team tools; commercial software development environments; computer science capstone programming projects; computer science education; computing disciplines; courseware; database courseware project; database management systems; Databases; experiential education; Experiential learning; interactive software modules; national science foundation; open source applications; open source software; Open-source software; professional software development environment; Programming; project documentation management; public domain software; software development; software engineering; students learning opportunities; task assignment; task tracking; version control","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"W2XN47KP","conferencePaper","2015","Corley, C. S.; Lois, F.; Quezada, S.","Web usage patterns of developers","Software Maintenance and Evolution (ICSME), 2015 IEEE International Conference on","","","10.1109/ICSM.2015.7332489","","Developers often rely on the web-based tools for troubleshooting, collaboration, issue tracking, code reviewing, documentation viewing, and a myriad of other uses. Developers also use the web for non-development purposes, such as reading news or social media. In this paper we explore whether web usage is detriment to a developer's focus on work from a sample over 150 developers. Additionally, we investigate if highly-focused developers use the web differently than other developers. Our qualitative findings suggest highly-focused developers use the web differently, but we are unable to predict a developer's focused based on web usage alone. Further quantitative findings suggest that web usage does not have a negative impact on a developer's focus.","2015-09","2016-03-14 21:38:57","2016-03-14 21:38:57","","381-390","","","","","","","","","","","","","","","","","","","","","","","","Blogs; Buildings; code reviewing; Collaboration; Debugging; developer focus; documentation viewing; Encoding; Heating; Internet; interruptions; personal software process; programming environments; Software; software engineering; troubleshooting; web activity; Web-based tool; Web usage pattern","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"VARE3MPS","conferencePaper","2013","Correa, D.; Lal, S.; Saini, A.; Sureka, A.","Samekana: A Browser Extension for Including Relevant Web Links in Issue Tracking System Discussion Forum","Software Engineering Conference (APSEC), 2013 20th Asia-Pacific","","","10.1109/APSEC.2013.15","","Several widely used Issue tracking systems (such as Google Issue Tracker and Bugzilla) contains an integrated threaded discussion forum to facilitate discussion between the development and maintenance team (bug reporters, bug triagers, bug fixers and quality assurance managers). We observe that several comments (and even bug report descriptions) posted to issue tracing system contains links to external websites as references to knowledge sources relevant to the discussion. We conduct a survey (and present the results of the survey) of Google Chromium Developers on the importance and usefulness of web references in issue tracking system comments and the need of a web-browser extension which facilitates easy organization and inclusion of web-links in the post. We conduct a characterization study on an experimental dataset from Google Chromium Issue Tracking system and present results on the distribution of number of links in the dataset, categorization of links into pre-defined classes (such as blogs, community based Q&A websites, developer discussion forums, version control system), correlation of number and types of links with various bug report types (such as security, crash, regression and clean-up) and relation between presence of links and bug resolution time. Survey results and data characterization study motivate the need of building a developer productivity tool to facilitate web-link (as references) organization and inclusion in issue tracking system comments. We present a Google Chromium Web Browser Extension called as Samekana and publish the extension on Google Chromium Web Store which can be freely downloaded by users worldwide. The extension contains features such as annotating (using tags, title and description) and saving web references pertaining to multiple bug reports and tasks and then posting it as bibliography (for easy citation and reference) in issue tracking system comments.","2013-12","2016-03-14 21:38:58","2016-03-14 21:38:58","","25-33","","","1","","","","","","","","","","","","","","","","","","","","","bibliography; Browsers; bug report descriptions; bug report types; bug resolution time; Bugzilla; building; Chromium; Computer crashes; data characterization; Developer Productivity Tool; Discussion forums; Empirical Software Engineering and Measurements (ESEM); Google; Google chromium developers; Google chromium issue tracking system; Google chromium Web browser extension; Google chromium Web store; Google issue tracker; including relevant Web links; Internet; issue tracing system; issue tracking system comments; issue tracking system discussion forum; maintenance team; Mining Bug Reports; Mining Software Repositories (MSR); online front-ends; productivity tool; Samekana; Software; software maintenance; Web references; Web sites","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"UIBZGQ3K","conferencePaper","2012","Hora, A.; Anquetil, N.; Ducasse, S.; Bhatti, M.; C. Couto; Valente, M. T.; Martins, J.","Bug Maps: A Tool for the Visual Exploration and Analysis of Bugs","Software Maintenance and Reengineering (CSMR), 2012 16th European Conference on","","","10.1109/CSMR.2012.68","","To harness the complexity of big legacy software, software engineering tools need more and more information on these systems. This information may come from analysis of the source code, study of execution traces, computing of metrics, etc. One source of information received less attention than source code: the bugs on the system. Little is known about the evolutionary behavior, lifetime, distribution, and stability of bugs. In this paper, we propose to consider bugs as first class entities and a useful source of information that can answer such topics. Such analysis is inherently complex, because bugs are intangible, invisible, and difficult to be traced. Therefore, our tool extracts information about bugs from bug tracking systems, link this information to other software artifacts, and explore interactive visualizations of bugs that we call bug maps.","2012-03","2016-03-14 21:38:58","2016-03-14 21:38:58","","523-526","","","","","","","","","","","","","","","","","","","","","","","","Browsers; bug maps; bugs analysis; bugs stability; bug tracking system; Color; Computer bugs; evolutionary behavior; evolutionary computation; History; information resources; information source; interactive bugs visualization; legacy software; Measurement; program debugging; program testing; Software; software artifact; software engineering tools; software maintenance; source code; visual exploration; Visualization","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"CCIRABPH","conferencePaper","2012","Nakamura, H.; Nagano, R.; Hisazumi, K.; Kamei, Y.; N. Ubayashi; Fukuda, A.","QORAL: An External Domain-Specific Language for Mining Software Repositories","Empirical Software Engineering in Practice (IWESEP), 2012 Fourth International Workshop on","","","10.1109/IWESEP.2012.20","","The mining software repositories (MSR) field integrates and analyzes data stored in repositories such as source control and bug repositories to provide support to practitioners. In order to provide useful information to practitioners, MSR researchers need to perform tasks iteratively, these tasks include extracting data from repositories, transforming them into specific data formats, and loading them into the statistical analysis tool. These tasks require a significant amount of man hours to implement and execute according to the requirements of the researchers. This paper proposes an external domain-specific language (DSL) called QORAL to facilitate the performance of multiple iterations and environment development. The results from a questionnaire used to evaluate QORAL indicate that it is easy to understand and modify source code.","2012-10","2016-03-14 21:38:58","2016-03-14 21:38:58","","23-29","","","","","","","","","","","","","","","","","","","","","","","","bug repository; bug tracking system; configuration management; data analysis; data extraction; data format; data integration; data mining; DSL; environment development; external domain-specific language; Grammar; libraries; Loading; Measurement; MSR; multiple iteration; program debugging; QORAL; Software; software engineering; software repository mining; source code modification; source control; statistical analysis tool; version control system","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"VXFS9G2I","journalArticle","2010","Zimmermann, T.; Premraj, R.; Bettenburg, N.; Just, S.; Schroter, A.; Weiss, C.","What Makes a Good Bug Report?","IEEE Transactions on Software Engineering","","0098-5589","10.1109/TSE.2010.63","","In software development, bug reports provide crucial information to developers. However, these reports widely differ in their quality. We conducted a survey among developers and users of APACHE, ECLIPSE, and MOZILLA to find out what makes a good bug report. The analysis of the 466 responses revealed an information mismatch between what developers need and what users supply. Most developers consider steps to reproduce, stack traces, and test cases as helpful, which are, at the same time, most difficult to provide for users. Such insight is helpful for designing new bug tracking tools that guide users at collecting and providing more helpful information. Our CUEZILLA prototype is such a tool and measures the quality of new bug reports; it also recommends which elements should be added to improve the quality. We trained CUEZILLA on a sample of 289 bug reports, rated by developers as part of the survey. The participants of our survey also provided 175 comments on hurdles in reporting and resolving bugs. Based on these comments, we discuss several recommendations for better bug tracking systems, which should focus on engaging bug reporters, better tool support, and improved handling of bug duplicates.","2010-09","2016-03-14 21:38:59","2016-03-14 21:38:59","","618-643","","5","36","","","","","","","","","","","","","","","","","","","","","and enhancement; APACHE; bug tracking tools; Computer bugs; CUEZILLA prototype; Debugging; distribution; Eclipse; Engineering management; Human factors; Information analysis; maintenance; management; measurement.; MOZILLA; program debugging; Programming; program testing; Prototypes; software development; software engineering; software maintenance; software quality; software testing; Testing and debugging","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"9FH3S3E6","conferencePaper","2010","Netto, F.; Barros, M. O.; Alvim, A. C. F.","An Automated Approach for Scheduling Bug Fix Tasks","Software Engineering (SBES), 2010 Brazilian Symposium on","","","10.1109/SBES.2010.16","","Even if a development team uses the best Software Engineering practices to produce high-quality software, end users may find defects that were not previously identified during the software development life-cycle. These defects must be fixed and new versions of the software incorporating the patches that solve them must be released. The project manager must schedule a set of error correction tasks with different priorities in order to minimize the time required to accomplish these tasks and guarantee that the more important issues have been fixed. Given the large number of distinct schedules, an automatically tool to find good schedules may be helpful to project managers. This work proposes a method which captures relevant information from bug repositories and submits them to a genetic algorithm to find near optimal bug correction task schedules. We have evaluated the approach using a subset of the Eclipse bug repository and it suggested better schedules than the actual schedules followed by Eclipse developers.","2010-09","2016-03-14 21:38:59","2016-03-14 21:38:59","","80-89","","","","","","","","","","","","","","","","","","","","","","","","Bismuth; bug resolution; Computer bugs; eclipse bug repository; error correction tasks; genetic algorithm; genetic algorithms; high-quality software; near optimal bug correction task schedules; Niobium; program debugging; Programming; Schedules; Search based software engineering; Software; software development life-cycle; software engineering; software engineering practices; software quality; task allocation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"U7NSFPEG","conferencePaper","2008","Anvik, J.; Storey, M. A.","Task articulation in software maintenance: Integrating source code annotations with an issue tracking system","Software Maintenance, 2008. ICSM 2008. IEEE International Conference on","","","10.1109/ICSM.2008.4658104","","Managing and articulating development tasks is an important aspect of software maintenance. Developers already have a variety of specialty tools to support task management, for example, issue tracking and configuration management software, but they also make use of other tools within their software engineering environments to support software task management. An example of one such mechanism is the appropriation of source code comments to document finer grained details of formally specified tasks. In this research, we propose and present a tool that integrates these source code annotations with an issue tracking management system. We describe how this tool addresses deficiencies that occur in task management and propose future research to improve task management.","2008-09","2016-03-14 21:38:59","2016-03-14 21:38:59","","460-461","","","","","","","","","","","","","","","","","","","","","","","","Collaborative software; Collaborative work; Computer science; configuration management software; Engineering management; Environmental management; groupware; issue tracking system; software development management; software engineering; software maintenance; software task management; Software tools; source code annotations; Tagging; task articulation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"54E7JVAU","conferencePaper","2012","Merten, T.; Schäfer, T.; Bürsner, S.","Using RE knowledge to assist automatically during requirement specification","Requirements Engineering Education and Training (REET), 2012 IEEE 7th International Workshop on","","","10.1109/REET.2012.6360068","","In a two semester software engineering (SE) course at Bonn-Rhine-Sieg University students have the opportunity to actually elicit, analyze and document requirements as well as design and develop a correspondent software product in teams of approximately four. The students have to use an issue tracking software in combination with a Requirements Engineering (RE) tool to document and plan their work. Though the course starts with RE theory from elicitation via documentation and traceability, we found that the students find it difficult to combine different RE artifact types and to develop useful traces between them. In this paper we present an approach to provide feedback and give pro-active advice inside an RE tool, while the specification is created. To derive this feedback we use a knowledge base containing rules and best practices to create a requirements specification. An assistance system applies these rules to guide the user in different situations, beginning with an empty specification up to the implementation of various RE artifact types and traces between them. This paper presents the status of our knowledge-based feedback mechanism and possible extensions. In order to get primary indicators for the value of this approach we did experiments and workshops with eight students who worked with the same tool with and without the feedback system.","2012-09","2016-03-14 21:38:59","2016-03-14 21:38:59","","9-13","","","","","","","","","","","","","","","","","","","","","","","","Cognition; Concrete; direct feedback; Documentation; Education; knowledge based systems; Knowledge engineering; RE; Software; software-based feedback agents; teaching","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"JBMG6PGJ","conferencePaper","2013","Bissyandé, T. F.; Thung, F.; Wang, S.; Lo, D.; Jiang, L.; Réveillère, L.","Empirical Evaluation of Bug Linking","Software Maintenance and Reengineering (CSMR), 2013 17th European Conference on","","","10.1109/CSMR.2013.19","","To collect software bugs found by users, development teams often set up bug trackers using systems such as Bugzilla. Developers would then fix some of the bugs and commit corresponding code changes into version control systems such as svn or git. Unfortunately, the links between bug reports and code changes are missing for many software projects as the bug tracking and version control systems are often maintained separately. Yet, linking bug reports to fix commits is important as it could shed light into the nature of bug fixing processes and expose patterns in software management. Bug linking solutions, such as ReLink, have been proposed. The demonstration of their effectiveness however faces a number of issues, including a reliability issue with their ground truth datasets as well as the extent of their measurements. We propose in this study a benchmark for evaluating bug linking solutions. This benchmark includes a dataset of about 12,000 bug links from 10 programs. These true links between bug reports and their fixes have been provided during bug fixing processes. We designed a number of research questions, to assess both quantitatively and qualitatively the effectiveness of a bug linking tool. Finally, we apply this benchmark on ReLink to report the strengths and limitations of this bug linking tool.","2013-03","2016-03-14 21:39:00","2016-03-14 21:39:00","","89-98","","","","","","","","","","","","","","","","","","","","","","","","benchmark; Benchmark testing; Bug Linking; bug linking empirical evaluation; bug linking tool; bug tracking system; Bugzilla system; code change; Computer bugs; Control systems; empirical evaluation; ground truth dataset; Information retrieval; Joining processes; missing links; program debugging; ReLink; ReLink solution; Software; software bug collection; software engineering; software management; software project; Training data; version control system","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"DADMC4DF","conferencePaper","2014","Saha, R. K.; Lawall, J.; Khurshid, S.; Perry, D. E.","On the Effectiveness of Information Retrieval Based Bug Localization for C Programs","Software Maintenance and Evolution (ICSME), 2014 IEEE International Conference on","","","10.1109/ICSME.2014.38","","Localizing bugs is important, difficult, and expensive, especially for large software projects. To address this problem, information retrieval (IR) based bug localization has increasingly been used to suggest potential buggy files given a bug report. To date, researchers have proposed a number of IR techniques for bug localization and empirically evaluated them to understand their effectiveness. However, virtually all of the evaluations have been limited to the projects written in object-oriented programming languages, particularly Java. Therefore, the effectiveness of these techniques for other widely used languages such as C is still unknown. In this paper, we create a benchmark dataset consisting of more than 7,500 bug reports from five popular C projects and rigorously evaluate our recently introduced IR-based bug localization tool using this dataset. Our results indicate that although the IR-relevant properties of C and Java programs are different, IR-based bug localization in C software at the file level is overall as effective as in Java software. However, we also find that the recent advance of using program structure information in performing bug localization gives less of a benefit for C software than for Java software.","2014-09","2016-03-14 21:39:00","2016-03-14 21:39:00","","161-170","","","","","","","","","","","","","","","","","","","","","","","","Accuracy; buggy files; Bug Localization; C language; C programs; Information retrieval; Java; Java programs; Kernel; Linux; Measurement; object-oriented programming; object-oriented programming languages; program debugging; Search; software projects","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"RWNRG694","journalArticle","2015","Ye, X.; Bunescu, R.; Liu, C.","Mapping Bug Reports to Relevant Files: A Ranking Model, a Fine-grained Benchmark, and Feature Evaluation","IEEE Transactions on Software Engineering","","0098-5589","10.1109/TSE.2015.2479232","","When a new bug report is received, developers usually need to reproduce the bug and perform code reviews to find the cause, a process that can be tedious and time consuming. A tool for ranking all the source files with respect to how likely they are to contain the cause of the bug would enable developers to narrow down their search and improve productivity. This paper introduces an adaptive ranking approach that leverages project knowledge through functional decomposition of source code, API descriptions of library components, the bug-fixing history, the code change history, and the file dependency graph. Given a bug report, the ranking score of each source file is computed as a weighted combination of an array of features, where the weights are trained automatically on previously solved bug reports using a learning-to-rank technique. We evaluate the ranking system on six large scale open source Java projects, using the before-fix version of the project for every bug report. The experimental results show that the learning-to-rank approach outperforms three recent state-of-the-art methods. In particular, our method makes correct recommendations within the top 10 ranked source files for over 70% of the bug reports in the Eclipse Platform and Tomcat projects.","2015","2016-03-14 21:39:01","2016-03-14 21:39:01","","1-1","","99","PP","","","","","","","","","","","","","","","","","","","","","Benchmark testing; Bug Reports; Collaboration; Computational modeling; Computer bugs; History; learning to rank; Software; software maintenance; Standards","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"T2WJUG6I","journalArticle","1998","Callahan, J. R.; Khatsuriya, R. R.; Hefner, R.","Web-based issue tracking for large software projects","IEEE Internet Computing","","1089-7801","10.1109/4236.722227","","Many problems are found and fixed during the development of a software system. The Project Issue Tracking System toolkit, a Web-based issue-management tool, can be used to organize issue reports during development and to communicate with different project teams around the world. The Project Issue Tracking System (PITS) is a tool that supports the IV&V effort for two major NASA projects: the Earth Observation System Data and Information System (EOSDIS) and the Earth Science Data and Information System (ESDIS). The EOSDIS IV&V effort teams several companies and organizations at several sites with Intermetrics, Inc, serving as the lead contractor. We examine the PITS Web-based mechanisms for tracking issue reports","1998-09","2016-03-14 21:39:01","2016-03-14 21:39:01","","25-33","","5","2","","","","","","","","","","","","","","","","","","","","","Communication effectiveness; computer aided software engineering; Computer errors; Databases; Earth Observation System Data and Information System; Earth Science Data and Information System; Environmental management; geophysics computing; Geoscience; Information systems; Intermetrics; Internet; issue-management tool; issue tracking; large software projects; NASA; NASA projects; Personnel; PITS; Project Issue Tracking System; scientific information systems; software development; software development management; Software tools; World Wide Web","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"SS7HB58F","conferencePaper","2009","Legenhausen, M.; Pielicke, S.; Rühmkorf, J.; Wendel, H.; Schreiber, A.","RepoGuard: A Framework for Integration of Development Tools with Source Code Repositories","Global Software Engineering, 2009. ICGSE 2009. Fourth IEEE International Conference on","","","10.1109/ICGSE.2009.51","","Today modern software development is not possible without the aid of tools like version control systems, bug tracking systems or instruments that ensure the compliance with code conventions. Unfortunately, all of these tools ldquolive in their own worldrdquo, are only loosely coupled and do not interact with each other. RepoGuard addresses this problem by linking version control systems to other software development tools. It is implemented as an extension to several version control systems and provides interfaces to integrate other tools. The use of RepoGuard allows maximum control and validation of all committed resources before they are permanently stored. Additionally, RepoGuard provides communication channels in order to inform all relevant stakeholders about the failure or success of the process. Overall, RepoGuard provides simple but effective means to guarantee software quality standards in distributed development processes.","2009-07","2016-03-14 21:39:01","2016-03-14 21:39:01","","328-331","","","","","","","","","","","","","","","","","","","","","","","","Communication system control; Computer languages; Control systems; development tools; distributed development process; distributed processing; Engines; Java; Performance evaluation; Permission; Programming; RepoGuard; software development; software quality; Software tools; source code repositories; source coding; Testing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"7I54HEBK","conferencePaper","2015","Izquierdo, J. L. C.; Cosentino, V.; Rolandi, B.; Bergel, A.; Cabot, J.","GiLA: GitHub label analyzer","Software Analysis, Evolution and Reengineering (SANER), 2015 IEEE 22nd International Conference on","","","10.1109/SANER.2015.7081860","","Reporting bugs, asking for new features and in general giving any kind of feedback is a common way to contribute to an Open-Source Software (OSS) project. In GitHub, the largest code hosting service for OSS, this feedback is typically expressed as new issues for the project managed by an issue-tracking system available in each new project repository. Among other features, the issue tracker allows creating and assigning labels to issues with the goal of helping the project community to better classify and manage those issues (e.g., facilitating the identification of issues for top priority components or candidate developers that could solve them). Nevertheless, as the project grows a manual browsing of the project issues is no longer feasible. In this paper we present GiLA, a tool which generates a set of visualizations to facilitate the analysis of issues in a project depending on their label-based categorization. We believe our visualizations are useful to see the most popular labels (and their relationships) in a project, identify the most active community members for those labels and compare the typical issue evolution for each label category.","2015-03","2016-03-14 21:39:02","2016-03-14 21:39:02","","479-483","","","","","","","","","","","","","","","","","","","","","","","","active community members; code hosting service; Communities; Computer architecture; Databases; GiLA; GitHub label analyzer; issue tracker; issue-tracking system; label-based categorization; open-source software project; OSS project; program visualisation; project community; Project management; project repository; public domain software; Servers; software development management; source code (software); Visualization; visualizations; Web services","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"7E526DEU","conferencePaper","2014","Behl, D.; Handa, S.; Arora, A.","A bug Mining tool to identify and analyze security bugs using Naive Bayes and TF-IDF","Optimization, Reliabilty, and Information Technology (ICROIT), 2014 International Conference on","","","10.1109/ICROIT.2014.6798341","","Bug report contains a vital role during software development, However bug reports belongs to different categories such as performance, usability, security etc. This paper focuses on security bug and presents a bug mining system for the identification of security and non-security bugs using the term frequency-inverse document frequency (TF-IDF) weights and naïve bayes. We performed experiments on bug report repositories of bug tracking systems such as bugzilla and debugger. In the proposed approach we apply text mining methodology and TF-IDF on the existing historic bug report database based on the bug s description to predict the nature of the bug and to train a statistical model for manually mislabeled bug reports present in the database. The tool helps in deciding the priorities of the incoming bugs depending on the category of the bugs i.e. whether it is a security bug report or a non-security bug report, using naïve bayes. Our evaluation shows that our tool using TF-IDF is giving better results than the naïve bayes method.","2014-02","2016-03-14 21:39:02","2016-03-14 21:39:02","","294-299","","","","","","","","","","","","","","","","","","","","","","","","Bayes methods; bug; bug mining tool; bug tracking systems; Computer bugs; data mining; historic bug report database; Integrated circuit modeling; mining; Naïve Bayes; Naive Bayes method; nonsecurity bug identification; nonsecurity bug report; non-security bug report; security bug report; security bug reports; security bugs identification; security of data; software development; statistical analysis; statistical model; term frequency-inverse document frequency weights; text analysis; text mining methodology; TF-IDF; Vectors","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"F94B9E4F","conferencePaper","2014","Hansson, D.","Continuous Linting with Automatic Debug","Microprocessor Test and Verification Workshop (MTV), 2014 15th International","","","10.1109/MTV.2014.25","","Lint tools analyze RTL statically and report code segments that do not comply with the selected coding guidelines. It is quick to run and as the error messages are very precise it is easy to fix the issues. It requires much less resources to fix a linting issue than to find and fix the same issue during simulation of a test. However, the large amounts of error and warning messages that the linting tools produce is a problem. Developers tend to push out linting until the very last moment just before the release. The engineers have plenty of critical test failures to attend to first, so it is a rational decision. However, this does not use the full potential of linting, because linting errors are very quick to fix, and some of the reported linting issues will be the same issues that takes much longer to debug during simulation. Pushing linting to the end of the project misses the opportunity to save a lot of time, but on the other hand developers cannot waste time by running the lint tool every now and again just-in-case they would find some good bugs. The solution is what we call continuous linting, where we combine the linting tool with an automatic debug tool of regression failures. At the start of the project we select the subset of the coding guidelines that the design must comply to. The automatic debug tool then runs the linting tool regularly, e.g. Each night, and when a linting issue is detected then the automatic debug tool sends a bug report to each individual with a list of linting errors this person has caused and in which commit they were introduced. We believe this unleashes the full potential of linting. By reporting the issues immediately to the individual that caused them instead of waiting to the end of the project, issues are fixed earlier at no extra human effort. The issues have to be fixed at some point and better sooner than later. This is all made possible by the automatic debug tool. As the engineers will fix their linting issues immediately- this will probably save time as some of the simulation bugs will be fixed faster and with less effort as more issues will be fixed due to linting error messages and fewer by manually analyzing simulation failures. In this paper we present the experience from a real ASIC project using continuous linting. We measured the number of linting issues that the automatic debug tool reported over a two month period. At the end of this period there were 0 linting issues outstanding. Had we waited until the end of the project to look at the lint issues there would have been 3617 lint issues in total to analyze. This is bound to have a significant positive effect on the project. The cost of fixing linting issues immediately by the person that just caused them is much less than for an engineer to sift through large amounts of lint errors and warnings at the end of the project.","2014-12","2016-03-14 21:39:02","2016-03-14 21:39:02","","70-72","","","","","","","","","","","","","","","","","","","","","","","","application specific integrated circuits; ASIC project; automatic debug; automatic debug tool; code segments; coding guidelines; Computer bugs; computer debugging; continuous linting; Encoding; Guidelines; IEEE Potentials; linting error messages; linting issues; linting tools; lint warnings; Manuals; program debugging; program testing; regression failures; regression testing; RTL; simulation bugs; simulation failures; software fault tolerance; Software tools; source code (software); Testing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"7CR8AW3V","conferencePaper","2015","An, L.; Khomh, F.","Challenges and Issues of Mining Crash Reports","Software Analytics (SWAN), 2015 IEEE 1st International Workshop on","","","10.1109/SWAN.2015.7070480","","Automatic crash reporting tools built in many software systems allow software practitioners to understand the origin of field crashes and help them prioritise field crashes or bugs, locate erroneous files, and/or predict bugs and crash occurrences in subsequent versions of the software systems. In this paper, after illustrating the structure of crash reports in Mozilla, we discuss some techniques for mining information from crash reports, and highlight the challenges and issues of these techniques. Our aim is to raise the awareness of the research community about issues that may bias research results obtained from crash reports and provide some guidelines to address certain challenges related to mining crash reports.","2015-03","2016-03-14 21:39:04","2016-03-14 21:39:04","","5-8","","","","","","","","","","","","","","","","","","","","","","","","Algorithm design and analysis; bug report; Computer bugs; crash report; crash reporting tool; crash report mining; Databases; data mining; mining softwarerepositories.; program debugging; program testing; Software systems","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"6B8PITCI","conferencePaper","2010","Wang, D.; Lin, M.; Zhang, H.; Hu, H.","Detect Related Bugs from Source Code Using Bug Information","Computer Software and Applications Conference (COMPSAC), 2010 IEEE 34th Annual","","","10.1109/COMPSAC.2010.27","","Open source projects often maintain open bug repositories during development and maintenance, and the reporters often point out straightly or implicitly the reasons why bugs occur when they submit them. The comments about a bug are very valuable for developers to locate and fix the bug. Meanwhile, it is very common in large software for programmers to override or overload some methods according to the same logic. If one method causes a bug, it is obvious that other overridden or overloaded methods maybe cause related or similar bugs. In this paper, we propose and implement a tool Rebug-Detector, which detects related bugs using bug information and code features. Firstly, it extracts bug features from bug information in bug repositories; secondly, it locates bug methods from source code, and then extracts code features of bug methods; thirdly, it calculates similarities between each overridden or overloaded method and bug methods; lastly, it determines which method maybe causes potential related or similar bugs. We evaluate Rebug-Detector on an open source project: Apache Lucene-Java. Our tool totally detects 61 related bugs, including 21 real bugs and 10 suspected bugs, and it costs us about 15.5 minutes. The results show that bug features and code features extracted by our tool are useful to find real bugs in existing projects.","2010-07","2016-03-14 21:39:04","2016-03-14 21:39:04","","228-237","","","","","","","","","","","","","","","","","","","","","","","","Apache Lucene-Java; bug detection; bug features; bug information; bug repository; code features; common substring; Computer bugs; data mining; Documentation; feature extraction; Java; open source project; program debugging; Programming; public domain software; Rebug- Detector; Rebug-Detector; Software; source code; source coding","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"UEBE9IWD","conferencePaper","2014","Mauša, G.; Grbac, T. G.; Bašić, B. D.","Software defect prediction with Bug-Code analyzer - A data collection tool demo","Software, Telecommunications and Computer Networks (SoftCOM), 2014 22nd International Conference on","","","10.1109/SOFTCOM.2014.7039122","","Empirical software engineering research community aims to accumulate knowledge in software engineering community based on the empirical studies on datasets obtained from the real software projects. Limiting factor to building the theory over thus accumulated knowledge is often related to dataset bias. One solution to this problem is developing a systematic data collection procedure through standard guidelines that would be available to open community and thus enable reducing data collection bias. In this paper we present a tool demonstration that implements a systematic data collection procedure for software defect prediction datasets from the open source bug tracking and the source code management repositories. Main challenging issue that the tool addresses is linking the information related to the same entity (e.g. class file) from these two sources. The tool implements interfaces to bug and source code repositories and even other tools for calculating the software metrics. Finally, it offers the user to create software defect prediction datasets even if he is unaware of all the details behind this complex task.","2014-09","2016-03-14 21:39:04","2016-03-14 21:39:04","","425-426","","","","","","","","","","","","","","","","","","","","","","","","Automated Tool; bug-code analyzer; class file; Communities; complex task; Computer bugs; Data collection; data collection bias reduction; data collection tool; empirical software engineering research community; Joining processes; Measurement; mining software repositories; open community; open source bug tracking; program debugging; program testing; public domain software; real software projects; Software; Software Defect Prediction; software defect prediction datasets; software engineering; software metrics; source code management repositories; source code (software); standard guidelines; systematic data collection procedure","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"A6IPV93K","conferencePaper","2014","Sasso, T. Dal; Lanza, M.","In #x2217;bug: Visual analytics of bug repositories","Software Maintenance, Reengineering and Reverse Engineering (CSMR-WCRE), 2014 Software Evolution Week - IEEE Conference on","","","10.1109/CSMR-WCRE.2014.6747208","","Bug tracking systems are used to track and store the defects reported during the life of software projects. The underlying repositories represent a valuable source of information used for example for defect prediction and program comprehension. However, bug tracking systems present the actual bugs essentially in textual form, which is not only cumbersome to navigate, but also hinders the understanding of the intricate pieces of information that revolve around software bugs. We present in*Bug, a web-based visual analytics platform to navigate and inspect bug repositories. in*Bug provides several interactive views to understand detailed information about the bugs and the people that report them. The tool can be downloaded at http://inbug.inf.usi.ch","2014-02","2016-03-14 21:39:05","2016-03-14 21:39:05","","415-419","","","","","","","","","","","","","","","","","","","","","","","","bug repositories; bug tracking systems; Complexity theory; Computer bugs; data visualisation; data visualization; defect prediction; in*Bug; information repositories; information storage; Navigation; program comprehension; program debugging; Software; software bugs; software projects; Software tools; Visual analytics; Web-based visual analytics platform","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"59QFP4CX","conferencePaper","2012","Wu, X.; Wei, J.; Wang, X.","Debug Concurrent Programs with Visualization and Inference of Event Structure","Software Engineering Conference (APSEC), 2012 19th Asia-Pacific","","","10.1109/APSEC.2012.134","","Owing to the inherent non-determinism of concurrent programs, traditional debugging techniques are not sufficient, especially in the scene of postmortem debugging. Exploring defects through static analysis can avoid the high cost of failure reproduction. In this paper, we present a novel debugging method for concurrency bugs. We make use of information in bug reports and slicing techniques, construct an event structure model from Java program to reveal the program behaviors related to the suspicious variables and methods identified from bug reports. Utilize the nature of event structure, we extract a small but sufficient subset from all possible execution traces and visualize them with a graph. This method can effectively help to comprehend concurrent system and assist in locating concurrency bugs. We have implemented a tool called JESVisT (Java event structure visualization Tool) to support this method based on open-source projects Bandera and Indus.","2012-12","2016-03-14 21:39:05","2016-03-14 21:39:05","","683-692","","","1","","","","","","","","","","","","","","","","","","","","","Bandera; bug report; Computer bugs; concurrency bug; concurrency control; Concurrent computing; concurrent program; concurrent programs; concurrent system; Debug; Debugging; debugging method; debugging technique; event structure; event structure model; failure reproduction cost; graph visualization; Indus; Java; Java event structure visualization tool; Java program; JESVisT tool; open-source project; postmortem debugging; program behavior; program debugging; program diagnostics; program visualisation; public domain software; slicing technique; Software; static analysis; Testing; Visualization","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"6NGX3QF3","conferencePaper","2013","Hansson, D.; Uronen-Hansson, H.","Measuring the Gain of Automatic Debug","Microprocessor Test and Verification (MTV), 2013 14th International Workshop on","","","10.1109/MTV.2013.17","","The purpose of regression testing is to quickly catch any deterioration in quality of a product under development. The more frequently tests are run, the earlier new issues can be detected resulting in a larger burden for the engineers who need to manually debug all test failures, many of which are failing due to the same underlying bug. However, there are software tools that automatically debug the test failures back to the faulty change and notifies the engineer who made this change. By analyzing data from a real commercial ASIC project we aimed to measure whether bugs are fixed faster when using automatic debug tools compared to manual debugging. All bugs in an ASIC development project were analyzed over a period of 3 months in order to determine the time it took the bug to be fixed and to compare the results from both automatic and manual debug. By measuring the time from when the bug report was sent out by the automatic debug tool until the bug was fixed, we can show that bugs are fixed 4 times faster with automatic debug enabled. Bug fixing time was on average 5.7 hours with automatic debug and 23.0 hours for manual debug. The result was achieved by comparing bugs that were automatically debugged to those issues that could not be debugged by the tool, because those issues were outside the defined scope of the device under test. Such issues are still reported by the automatic debug tool but marked as requiring manual debug and is consequently a good point of comparison. A 4 times quicker bug fixing process is significant and can ultimately contribute to a shortening of a development project as the bug turnaround time is one of the key aspects defining the length of a project, especially in the later phase just before release.","2013-12","2016-03-14 21:39:05","2016-03-14 21:39:05","","19-22","","","","","","","","","","","","","","","","","","","","","","","","application specific integrated circuits; ASIC development project; automatic debug; automatic debug tools; bug fixing process; bug report; bug turnaround time; commercial ASIC project; Computer bugs; continuous integration; Delays; Electronic mail; integrated circuit testing; manual debugging; Manuals; program debugging; regression analysis; regression testing; Software tools; system-on-chip verification; test failures debug; Testing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"N2S6KWBB","journalArticle","2005","Serrano, N.; Ciordia, I.","Bugzilla, ITracker, and other bug trackers","IEEE Software","","0740-7459","10.1109/MS.2005.32","","Bug-tracking helps the software developers in knowing what the error is, resolving it, and learning from it. Working on a software project includes managing the bugs we find. At first, we might list them on a spreadsheet. But when the number of bugs becomes too large and a lot of people must access and input data on them, we have to give up the spreadsheet and instead use a bug- or issue-tracking system. Many software projects reach this point, especially during testing and deployment when users tend to find an application's bugs. Nowadays we can choose among dozens of bug-tracking systems. This paper looks at two specific open source products and provides useful hints for working with any bug-tracking tool.","2005-03","2016-03-14 21:39:05","2016-03-14 21:39:05","","11-13","","2","22","","","","","","","","","","","","","","","","","","","","","Application software; bug database; bug tracker; bug-tracking system; bug-tracking tool; Computer bugs; Control systems; Filters; Information systems; issues database; Linux; NASA; open source product; open source software; program debugging; program diagnostics; program testing; public domain software; Software tools; Spatial databases","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"54RGK799","conferencePaper","2006","Ko, A. J.; Myers, B. A.; Chau, Duen Horng","A Linguistic Analysis of How People Describe Software Problems","Visual Languages and Human-Centric Computing, 2006. VL/HCC 2006. IEEE Symposium on","","","10.1109/VLHCC.2006.3","","There is little understanding of how people describe software problems, but a variety of tools solicit, manage, and analyze these descriptions in order to streamline software development. To inform the design of these tools and generate ideas for new ones, an study of nearly 200,000 bug report titles was performed. The titles of the reports generally described a software entity or behavior, its inadequacy, and an execution context, suggesting new designs for more structured report forms. About 95% of noun phrases referred to visible software entities, physical devices, or user actions, suggesting the feasibility of allowing users to select these entities in debuggers and other tools. Also, the structure of the titles exhibited sufficient regularity to parse with an accuracy of 89%, enabling a number of new automated analyses. These findings and others have many implications for tool design and software engineering","2006-09","2016-03-14 21:39:06","2016-03-14 21:39:06","","127-134","","","","","","","","","","","","","","","","","","","","","","","","computational linguistics; linguistic analysis; open source software; Programming; Software debugging; Software design; software development; software development management; software engineering; software maintenance; software problems; Software tools; tool design; Usability; User interfaces","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"JR78UQKB","conferencePaper","2010","Stepalina, E.","SaaS support in software documentation systems","Software Engineering Conference (CEE-SECR), 2010 6th Central and Eastern European","","","10.1109/CEE-SECR.2010.5783175","","In recent days more and more software developments tools become distributed by the SaaS (Software-As-A Service) model alongside with ready-to-install products. The developers of task and bug tracking systems now offer their solutions by a monthly fee. For instance, JIRA Studio produced by Atlassian can be connected to a corporative domain by subscription. This scheme allows software companies to reduce costs at the project's start and get scalable resources in future. Software documentation systems can also be purchased by a subscription now. The effectiveness of their usage for various documentation development is interesting. There are four major types of documentation supporting the development process and resulted products: project, technical, code and user documentation. Each of this type claims specific requirements for the documentation tool. The requirement analysis shows that rented documentation systems are the most appropriate for user and technical documentation. There are two major classes of software documentation systems: 1) Wiki, 2) DITA-orientedXML CMS. The following wiki systems have a hosted version: commercial Confluence, Central Desktop, EditMe, Incentive, Netcipia, PBWiki, Wikia, Wikispaces; open source BusinessWiki, Metadot Wiki, MindTouch, Wagn, Wikidot. The richest by the functionality andplugin collection is Confluence produced by Atlassian. The following XML CMS are offered by a SaaS model (all are commercial): Astoria On Demand, DITA Exchange. DocZone. SaaS is optionally supported in Bluestream XDocs, Siberlogic SiberSafe, Trisoft Infoshare, Vasont, X-Hive Docato. As wiki system is a ready integrated environment for creating and publishing documentation, DITA-system consists not only of XML CMS. To deploy a DITA-system, you should have an XML editor, publisher and CMS. The listed CMS can be integrated with top DITA XML editors and provide an API to integrate with other editors. These CMS also have build-in tools to export documents in mu- - ltiple formats. However, the universal component architecture of DITA-systems makes the deployment and configuration more difficult than wiki implementation. Hosted documentation systems are offered by different prices. The offerings of top documentation systems are considered in this paper. Wiki subscription fees range from 4,95$ (EditMe) to 20$ (Confluence) per one user/month. XML CMS subscription price starts from 500$ per month and can reach 12000$ per month. These subscriptions have no fixed price; in each individual case the CMS vendor performs a specific project of a DITA-system implementation. Wiki rental costs approximate to CMS subscriptions' costs for large number of users, 500 and more. The advantages of renting a powerful documentation system for small and large project are the following: 1) Maximal functionality at a low affordable cost, 2) Platform independency and high system accessibility, 3) Document quality improvement at the expense of quality controlling tools application, 4) Higher effectiveness of documentation (content re-use, single source usage, automated tools for localization), 5) Organization of robust and scalable documentation process. As the SaaS business model becomes more popular, small companies get access to powerful software documentation systems, which are too expensive to purchase a standalone license at the startup. However, the system's access security, reliability and information confidentiality issues remain opened and controversial.","2010-10","2016-03-14 21:39:06","2016-03-14 21:39:06","","192-197","","","","","","","","","","","","","","","","","","","","","","","","Astoria On Demand; Atlassian; Bluestream XDocs; bug tracking systems; Central Desktop; cloud computing; Confluence; DITA Exchange; DITA-orientedXML CMS; Documentation; documentation publishing; document handling; DocZone; EditMe; Electronic publishing; Google; Incentive; Information services; Internet; JIRA Studio; Metadot Wiki; MindTouch; Netcipia; open source BusinessWiki; PBWiki; quality controlling tools application; ready-to-install products; requirement analysis; SaaS; SaaS business model; SaaS support; Siberlogic SiberSafe; software companies; software developments tools; Software documentation; software documentation systems; software engineering; Subscriptions; systems analysis; task tracking systems; Trisoft Infoshare; Wagn; Web sites; wiki; Wikia; Wikidot; Wikispaces; X-Hive Docato; XML; XML CMS; τasont","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"X822M293","conferencePaper","2012","Knauss, E.; Damian, D.; Poo-Caamaño, G.; Cleland-Huang, J.","Detecting and classifying patterns of requirements clarifications","Requirements Engineering Conference (RE), 2012 20th IEEE International","","","10.1109/RE.2012.6345811","","In current project environments, requirements often evolve throughout the project and are worked on by stakeholders in large and distributed teams. Such teams often use online tools such as mailing lists, bug tracking systems or online discussion forums to communicate, clarify or coordinate work on requirements. In this kind of environment, the expected evolution from initial idea, through clarification, to a stable requirement, often stagnates. When project managers are not aware of underlying problems, development may proceed before requirements are fully understood and stabilized, leading to numerous implementation issues and often resulting in the need for early redesign and modification. In this paper, we present an approach to analyzing online requirements communication and a method for the detection and classification of clarification events in requirement discussions. We used our approach to analyze online requirements communication in the IBM^® Rational Team Concert^® (RTC) project and identified a set of six clarification patterns. Since a predominant amount of clarifications through the lifetime of a requirement is often indicative of problematic requirements, our approach lends support to project managers to assess, in real-time, the state of discussions around a requirement and promptly react to requirements problems.","2012-09","2016-03-14 21:39:07","2016-03-14 21:39:07","","251-260","","","","","","","","","","","","","","","","","","","","","","","","clarification event classification; clarification event detection; communication of requirements; Context; distributed processing; distributed requirements engineering; distributed teams; formal verification; IBM^® Rational Team Concert^® project; Manuals; Message systems; Natural languages; online requirement communication; pattern classification; project environments; Project management; project managers; requirement clarification pattern; requirements clarification patterns; RTC project; Software; systems analysis; Trajectory; Visualization","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"3NKWBV3Z","conferencePaper","2009","Ardagna, C. A.; Banzi, M.; Damiani, E.; Frati, F.","Assurance Process for Large Open Source Code Bases","Computational Science and Engineering, 2009. CSE '09. International Conference on","","","10.1109/CSE.2009.271","","Many organizations are investigating the possibility of adopting open source software or migrating their mission critical applications to open platforms. In this context, defining an assurance process for large open source code bases has becomes of paramount importance, and can help in filling the gap with proprietary solutions. In this paper, we discuss how assurance has become a primary requirement for organizations wishing to adopt open source products. Then, we describe how bug tracking and fixing can be enriched to support a more general cycle of assurance, and we evaluate how this process can be applied to large-scale open source projects like JADE and WADE.","2009-08","2016-03-14 21:39:07","2016-03-14 21:39:07","","412-417","","","3","","","","","","","","","","","","","","","","","","","","","bug fixing; bug tracking; Computer architecture; issue tracking; JADE; Kernel; large open source code bases; Linux; Mission critical systems; open source software; Opne Source; program debugging; Programming; public domain software; Security; software assurance; software engineering; software quality; Technological innovation; Telecommunication computing; WADE","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"BICUEQKU","conferencePaper","2015","Le, T. D. B.; Linares-Vasquez, M.; Lo, D.; Poshyvanyk, D.","RCLinker: Automated Linking of Issue Reports and Commits Leveraging Rich Contextual Information","Program Comprehension (ICPC), 2015 IEEE 23rd International Conference on","","","10.1109/ICPC.2015.13","","Links between issue reports and their corresponding commits in version control systems are often missing. However, these links are important for measuring the quality of various parts of a software system, predicting defects, and many other tasks. A number of existing approaches have been designed to solve this problem by automatically linking bug reports to source code commits via comparison of textual information in commit messages with textual contents in the bug reports. Yet, the effectiveness of these techniques is oftentimes sub optimal when commit messages are empty or only contain minimum information, this particular problem makes the process of recovering trace ability links between commits and bug reports particularly challenging. In this work, we aim at improving the effectiveness of existing bug linking techniques by utilizing rich contextual information. We rely on a recently proposed tool, namely Change Scribe, which generates commit messages containing rich contextual information by using a number of code summarization techniques. Our approach then extracts features from these automatically generated commit messages and bug reports and inputs them into a classification technique that creates a discriminative model used to predict if a link exists between a commit message and a bug report. We compared our approach, coined as RCLinker (Rich Context Linker), to MLink, which is an existing state-of-the-art bug linking approach. Our experiment results on bug reports from 6 software projects show that RCLinker can outperform MLink in terms of F-measure by 138.66%.","2015-05","2016-03-14 21:39:07","2016-03-14 21:39:07","","36-47","","","","","","","","","","","","","","","","","","","","","","","","automated bug issue report linking; automated source code commit linking; ChangeScribe; Classification; classification technique; code summarization techniques; commit messages; configuration management; Control systems; defect prediction; discriminative model; feature extraction; F-measure; Joining processes; Metadata; MLink; Predictive models; program debugging; program diagnostics; RCLinker; Recovering Missing Links; Rich-Context Linker; rich-contextual information leveraging; software projects; software quality; software system quality; source code (software); textual information; traceability links; Training; version control systems; XML","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"7M6E5FKE","conferencePaper","2015","White, Martin; Linares-Vásquez, Mario; Johnson, Peter; Bernal-Cárdenas, Carlos; Poshyvanyk, Denys","Generating Reproducible and Replayable Bug Reports from Android Application Crashes","Proceedings of the 2015 IEEE 23rd International Conference on Program Comprehension","","","","http://dl.acm.org/citation.cfm?id=2820282.2820291","","2015","2016-03-14 21:39:50","2016-03-14 21:41:04","","48–59","","","","","","","ICPC '15","","","","IEEE Press","Piscataway, NJ, USA","","","","","","","","","","","","Android; Android application crashes; Android (operating system); Androids; bug diagnosis; call stack; Computer crashes; crash and bug reports; CRASHDROID approach; crash report; Databases; Humanoid robots; incomplete-noninformative bug reports; issue tracking system; Kernel; kernel event trace; kernel event traces; method call traces; Mobile communication; natural language descriptions; Natural languages; open-source Android applications; program debugging; reproducibility; reproducible replayable bug report generation; software maintenance; stress-testing tool; traceability links","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"X697FHGA","conferencePaper","2009","Ki, Yuhoon; Song, Meongchul","An Open Source-Based Approach to Software Development Infrastructures","Proceedings of the 2009 IEEE/ACM International Conference on Automated Software Engineering","978-0-7695-3891-4","","10.1109/ASE.2009.73","http://dx.doi.org/10.1109/ASE.2009.73","","2009","2016-03-14 21:39:52","2016-03-14 21:40:56","","525–529","","","","","","","ASE '09","","","","IEEE Computer Society","Washington, DC, USA","","","","","","","","","","","","automated software engineering tools; Automation; collaborated information; Collaborative software; Collaborative tools; configuration management; continuous integration; continuous integration tool; groupware; integrated software; issue tracking; open source; open source software; open source tools; program diagnostics; Programming; public domain software; SCM; software configuration management tool; software development cycle; software development management; software engineering; software engineering tools; software quality; Software systems; Software tools; Testing; tracking tool; TRICA","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"ISP39GNJ","conferencePaper","2010","Song, Yoonki; Wang, Xiaoyin; Xie, Tao; Zhang, Lu; Mei, Hong","JDF: Detecting Duplicate Bug Reports in Jazz","Proceedings of the 32Nd ACM/IEEE International Conference on Software Engineering - Volume 2","978-1-60558-719-6","","10.1145/1810295.1810368","http://doi.acm.org/10.1145/1810295.1810368","","2010","2016-03-14 21:39:52","2016-03-14 21:41:07","","315–316","","","","","","","ICSE '10","","","","ACM","New York, NY, USA","","","","","","","","","","","","bug report; Bug Reports; bug repository; Calculators; Computer architecture; Educational institutions; execution information; groupware; Information retrieval; JDF; Measurement; natural language; natural language processing; Natural languages; process management; Servers; Software; software development; software development management; software quality; team collaboration; team working","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"HDEKDXG6","conferencePaper","2010","Helming, Jonas; Koegel, Maximilian","Managing Iterations with UNICASE","Proceedings of the 32Nd ACM/IEEE International Conference on Software Engineering - Volume 2","978-1-60558-719-6","","10.1145/1810295.1810367","http://doi.acm.org/10.1145/1810295.1810367","","2010","2016-03-14 21:40:03","2016-03-14 21:41:11","","313–314","","","","","","","ICSE '10","","","","ACM","New York, NY, USA","","","","","","","","","","","","Analytical models; bug report; computer aided software engineering; Conferences; formal specification; iteration management; iteration planning; Planning; program debugging; Project management; requirements; Software; software development management; software engineering; software project; specification; System analysis and design; task; UNICASE; unified CASE tool; Unified modeling language","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"DZISSM3S","conferencePaper","2008","Storey, Margaret-Anne; Ryall, Jody; Bull, R. Ian; Myers, Del; Singer, Janice","TODO or to Bug: Exploring How Task Annotations Play a Role in the Work Practices of Software Developers","Proceedings of the 30th International Conference on Software Engineering","978-1-60558-079-1","","10.1145/1368088.1368123","http://doi.acm.org/10.1145/1368088.1368123","","2008","2016-03-14 21:40:04","2016-03-14 21:41:17","","251–260","","","","","","","ICSE '08","","","","ACM","New York, NY, USA","","","","","","","","","","","","collaborative activity; Collaborative software; Collaborative tools; Collaborative work; Embedded software; groupware; open source projects; open source software; program debugging; Programming profession; Project management; Protocols; public domain software; software developers; software development management; Software tools; source code comments; task analysis; task annotations; task management; To Bug; TODO; work practices","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"KZGP55VF","conferencePaper","2012","Keivanloo, Iman; Forbes, Christopher; Hmood, Aseel; Erfani, Mostafa; Neal, Christopher; Peristerakis, George; Rilling, Juergen","A Linked Data Platform for Mining Software Repositories","Proceedings of the 9th IEEE Working Conference on Mining Software Repositories","978-1-4673-1761-0","","","http://dl.acm.org/citation.cfm?id=2664446.2664451","","2012","2016-03-14 21:40:05","2016-03-14 21:40:52","","32–35","","","","","","","MSR '12","","","","IEEE Press","Piscataway, NJ, USA","","","","","","","","","","","","Cloning; code clones; collaborative platform; Communities; data mining; Encyclopedias; fact sharing; Licenses; Linked Data; linked data platform; mining software repositories; online software ecosystem linked data platform; on-the-fly inter-dataset integration; Ontologies; Software; software datasets; software licenses; software mining; software packages; software repositories; source code statements; value added information","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"ZRPNC24T","conferencePaper","2013","Bell, Jonathan; Sarda, Nikhil; Kaiser, Gail","Chronicler: Lightweight Recording to Reproduce Field Failures","Proceedings of the 2013 International Conference on Software Engineering","978-1-4673-3076-3","","","http://dl.acm.org/citation.cfm?id=2486788.2486836","","2013","2016-03-14 21:40:10","2016-03-14 21:40:59","","362–371","","","","","","","ICSE '13","","","","IEEE Press","Piscataway, NJ, USA","","","","","","","","","","","","advanced remote debugging tools; automated error reporting tools; bug report generation; CHRONICLERJ; Computer crashes; Debugging; Debugging aids; Error handling and recovery; failure diagnosis; field failures; Instruction sets; Instruments; Java; Java implementation; libraries; Maintainability; nondeterministic inputs; program debugging; Runtime; software fault tolerance; software maintenance; Software tools","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""